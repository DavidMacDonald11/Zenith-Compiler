// self: the current non-terminal
// next: the next non-terminal (not including parts)

expr : next ;

conditionExpr : next ["if" NL? next NL? "else" NL? self] ;

logicOrExpr : [self "or" NL?] next ;

logicXorExpr : [self "xor" NL?] next ;

logicAndExpr : [self "and" NL?] next ;

compareExpr : next (("<" | ">" | "<=" | ">=" | "==" | "!=") NL? next)* ;

bitOrExpr : [self "|" NL?] next ;

bitXorExpr : [self "$" NL?] next ;

bitAndExpr : [self "&" NL?] next ;

bitShiftExpr : [self ("<<" | ">>") NL?] next ;

addExpr : [self ("+" | "-") NL?] next ;

multiplyExpr : [self ("*" | "/" | "%") NL?] next ;

exponentExpr : next ["^" NL? self] ;

prefixExpr : ("+" | "-" | "~" | "not" | "$" | "&" | "#") NL? self
           | next
           ;

postfixExpr : self "!"
            | self NL? "." NL? ID
            | self "(" NL? [funArgs] NL? ")"
            | next
            ;

part funArgs : [pFunArgs "," NL?] dFunArgs
             | pFunArgs
             ;

part pFunArgs : [pFunArgs "," NL?] expr ;
part dFunArgs : [dFunArgs "," NL?] ID "=" NL? expr ;

primaryExpr : NUM
            | CHAR
            | STR
            | ID
            | ("true" | "false" | "none" | "undefined")
            | allocExpr
            | parenExpr
            ;

allocExpr : storageKey parenExpr ;
parenExpr : "(" NL? expr NL? ")"
