Manual Memory Management Made Easier

x Int := 15 // creates an int on the stack
y1 Int! := x! // creates a non-nullable int ref
y2 Int? := x? // creates a nullable int ref

z Int := 7
y1 = 7  // should set x to 7
y1! = z! // sets y1 to reference to z

func inc(n Int!) { n++ }
func fakeInc(n Int) := n + 1

inc(y1!) // passes y1 as a reference
fakeInc(y1) // passes y1 by value

y1! = null // error because y1 is not nullable
y2? = null // valid

inc(y2?) // error because inc expects non-nullable Int ref
inc(y2? ?? y1!) // inputs y2 if not null, otherwise y1 as ref
inc(y2!) // asserts that y2 is not null as ref

fakeInc(y2) // not valid because y2 may be null
fakeInc(y2 ?? 1) // inputs y2 or 1 if it is null
fakeInc(y2!!) // asserts that y2 is not null

Heap Allocation

# reference modifier
Int#? or Int#! // heap int

a1 Int#? = ...alloc... // heap value; is superset of Int?
inc(a1!) // asserts that a1 is not null ref

a2 Int#! = a1#! // asserts a1 not null heap ref

behaves exactly like refs and can be used as one
only these may be freed. assignment works one way (Int#? -> Int?)
